#!/usr/bin/env perl
#
# Copyright (c) 2014 Jerry Lundstr√∂m <lundstrom.jerry@gmail.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

use common::sense;
use JSON;
use utf8;
use Carp;
use Getopt::Long;

my $backend;
my $code = 0;
unless (GetOptions(
    'backend:s' => \$backend,
    'code' => \$code))
{
    die "Invalid command argument!";
}
if ($backend) {
    $backend = lc($backend);
}

my $JSON = JSON->new;

open(FILE, $ARGV[0]) or die;
my $file;
while (<FILE>) {
    $file .= $_;
}
close(FILE);

my %DB_TYPE_TO_C_TYPE = (
    DB_TYPE_PRIMARY_KEY => 'should_not_be_used',
    DB_TYPE_INT32 => 'int',
    DB_TYPE_UINT32 => 'unsigned int',
    DB_TYPE_INT64 => 'long long',
    DB_TYPE_UINT64 => 'unsigned long long',
    DB_TYPE_TEXT => 'char*'
);

my %DB_TYPE_TO_SQLITE = (
    DB_TYPE_PRIMARY_KEY => 'INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL',
    DB_TYPE_INT32 => 'INT NOT NULL',
    DB_TYPE_UINT32 => 'UNSIGNED INT NOT NULL',
    DB_TYPE_INT64 => 'BIGINT NOT NULL',
    DB_TYPE_UINT64 => 'UNSIGNED BIGINT NOT NULL',
    DB_TYPE_TEXT => 'TEXT NOT NULL',
    DB_TYPE_ENUM => 'INT NOT NULL',
    DB_TYPE_REVISION => 'INTEGER NOT NULL DEFAULT 1'
);

my %DB_TYPE_TO_MYSQL = (
    DB_TYPE_PRIMARY_KEY => 'BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT NOT NULL',
    DB_TYPE_INT32 => 'INT NOT NULL',
    DB_TYPE_UINT32 => 'INT UNSIGNED NOT NULL',
    DB_TYPE_INT64 => 'BIGINT NOT NULL',
    DB_TYPE_UINT64 => 'BIGINT UNSIGNED NOT NULL',
    DB_TYPE_TEXT => 'TEXT NOT NULL',
    DB_TYPE_ENUM => 'INT NOT NULL',
    DB_TYPE_REVISION => 'INT UNSIGNED NOT NULL DEFAULT 1'
);

my %DB_TYPE_TO_FUNC = (
    DB_TYPE_PRIMARY_KEY => 'should_not_be_used',
    DB_TYPE_INT32 => 'int32',
    DB_TYPE_UINT32 => 'uint32',
    DB_TYPE_INT64 => 'int64',
    DB_TYPE_UINT64 => 'uint64',
    DB_TYPE_TEXT => 'text'
);

my %DB_TYPE_TO_TEXT = (
    DB_TYPE_PRIMARY_KEY => 'a primary key database value',
    DB_TYPE_INT32 => 'an integer',
    DB_TYPE_UINT32 => 'an unsigned integer',
    DB_TYPE_INT64 => 'a long long',
    DB_TYPE_UINT64 => 'an unsigned long long',
    DB_TYPE_TEXT => 'a character pointer'
);

sub camelize {
    my $string = shift || confess;
    my $camelize = "";
    my @parts = split(/_/o, $string);

    $camelize = shift(@parts);
    foreach my $part (@parts) {
        $camelize .= ucfirst($part);
    }
    return $camelize;
}

my $objects = $JSON->decode($file);

#
# Generate SQLite schema
#

if (!$backend or $backend eq 'sqlite') {

    open(SQLITE, '>:encoding(UTF-8)', 'schema.sqlite') or die;

    print SQLITE '-- Autogenerated file by dbo-generate-objects
';
    foreach my $object (@$objects) {
        my $name = $object->{name};
        my $tname = $name;
        $tname =~ s/_/ /go;

        print SQLITE '
CREATE TABLE ', camelize($name), ' (
';
        my $first = 1;
        foreach my $field (@{$object->{fields}}) {
            if (!$first) {
                print SQLITE ',
';
            }
            $first = 0;
            if ($field->{type} eq 'DB_TYPE_PRIMARY_KEY') {
                print SQLITE '    ', camelize($field->{name}), ' ', $DB_TYPE_TO_SQLITE{'DB_TYPE_PRIMARY_KEY'};
                next;
            }
            if ($field->{foreign}) {
                print SQLITE '    ', camelize($field->{name}), ' INTEGER NOT NULL';
                next;
            }
            print SQLITE '    ', camelize($field->{name}), ' ', $DB_TYPE_TO_SQLITE{$field->{type}};
        }
        print SQLITE '
);
';
        foreach my $field (@{$object->{fields}}) {
            if ($field->{foreign}) {
                print SQLITE 'CREATE INDEX ', camelize($name.'_'.$field->{name}), ' ON ', camelize($name),' ( ', camelize($field->{name}), ' );
';
                next;
            }
            if ($field->{unique}) {
                print SQLITE 'CREATE UNIQUE INDEX ', camelize($name.'_'.$field->{name}), ' ON ', camelize($name),' ( ', camelize($field->{name}), ' );
';
                next;
            }
        }
    }
    close(SQLITE);
}

#
# Generate SQLite schema code
#

if ((!$backend or $backend eq 'sqlite') and $code) {

    open(SQLITE, '>:encoding(UTF-8)', 'libdbo_schema_sqlite.h') or die;

    print SQLITE '/*
 * Autogenerated file by dbo-generate-objects
 */

#ifndef libdbo_schema_sqlite_h
#define libdbo_schema_sqlite_h

#ifdef __cplusplus
extern "C" {
#endif

extern const char* libdbo_schema_sqlite_create[];
extern const char* libdbo_schema_sqlite_drop[];

#ifdef __cplusplus
}
#endif

#endif
';
    close(SQLITE);
    
    open(SQLITE, '>:encoding(UTF-8)', 'libdbo_schema_sqlite.c') or die;

    print SQLITE '/*
 * Autogenerated file by dbo-generate-objects
 */

const char* libdbo_schema_sqlite_create[] = {
';
    foreach my $object (@$objects) {
        my $name = $object->{name};
        my $tname = $name;
        $tname =~ s/_/ /go;
    
        my $first = 1;
        my $str = 'CREATE TABLE '.camelize($name).' (';
        foreach my $field (@{$object->{fields}}) {
            if (!$first) {
                $str .= ', ';
            }
            $first = 0;
            if ($field->{type} eq 'DB_TYPE_PRIMARY_KEY') {
                $str .= ' '.camelize($field->{name}).' '.$DB_TYPE_TO_SQLITE{'DB_TYPE_PRIMARY_KEY'};
                next;
            }
            if ($field->{foreign}) {
                $str .= ' '.camelize($field->{name}).' INTEGER NOT NULL';
                next;
            }
                $str .= ' '.camelize($field->{name}).' '.$DB_TYPE_TO_SQLITE{$field->{type}};
        }
        $str .= ')';
        my @parts = ( $str =~ m/.{1,500}/go );
        for my $part (@parts) {
            print SQLITE '    "', $part, '",
';
        }
        print SQLITE '    0,
';

        foreach my $field (@{$object->{fields}}) {
            my $str = '';
        
            if ($field->{foreign}) {
                $str = 'CREATE INDEX '.camelize($name.'_'.$field->{name}).' ON '.camelize($name).' ( '.camelize($field->{name}).' )';
            }
            if ($field->{unique}) {
                $str = 'CREATE UNIQUE INDEX '.camelize($name.'_'.$field->{name}).' ON '.camelize($name).' ( '.camelize($field->{name}).' )';
            }
            if (!$str) {
                next;
            }

            my @parts = ( $str =~ m/.{1,500}/go );
            for my $part (@parts) {
                print SQLITE '    "', $part, '",
';
            }
            print SQLITE '    0,
';
        }
    }
    print SQLITE '    0
};

const char* libdbo_schema_sqlite_drop[] = {
';
    foreach my $object (@$objects) {
        my $name = $object->{name};

        print SQLITE '    "DROP TABLE IF EXISTS ', camelize($name), '",
    0,
';
    }
    print SQLITE '    0
};
';
    close(SQLITE);
}

#
# Generate MySQL schema
#

if (!$backend or $backend eq 'mysql') {

    open(MYSQL, '>:encoding(UTF-8)', 'schema.mysql') or die;

    print MYSQL '-- Autogenerated file by dbo-generate-objects
';
    foreach my $object (@$objects) {
        my $name = $object->{name};
        my $tname = $name;
        $tname =~ s/_/ /go;

        print MYSQL '
CREATE TABLE ', camelize($name), ' (
';
        my $first = 1;
        foreach my $field (@{$object->{fields}}) {
            if (!$first) {
                print MYSQL ',
';
            }
            $first = 0;
            if ($field->{type} eq 'DB_TYPE_PRIMARY_KEY') {
                print MYSQL '    ', camelize($field->{name}), ' ', $DB_TYPE_TO_MYSQL{'DB_TYPE_PRIMARY_KEY'};
                next;
            }
            if ($field->{foreign}) {
                print MYSQL '    ', camelize($field->{name}), ' BIGINT UNSIGNED NOT NULL';
                next;
            }
                print MYSQL '    ', camelize($field->{name}), ' ', $DB_TYPE_TO_MYSQL{$field->{type}};
        }
        print MYSQL '
);
        ';
        foreach my $field (@{$object->{fields}}) {
            if ($field->{foreign}) {
                print MYSQL 'CREATE INDEX ', camelize($name.'_'.$field->{name}), ' ON ', camelize($name),' ( ', camelize($field->{name}), ($field->{type} eq 'DB_TYPE_TEXT' ? '(255)' : ''), ' );
';
                next;
            }
            if ($field->{unique}) {
                print MYSQL 'CREATE UNIQUE INDEX ', camelize($name.'_'.$field->{name}), ' ON ', camelize($name),' ( ', camelize($field->{name}), ($field->{type} eq 'DB_TYPE_TEXT' ? '(255)' : ''), ' );
';
                next;
            }
        }
    }
    close(MYSQL);

    open(MYSQL, '>:encoding(UTF-8)', 'drop.mysql') or die;

    print MYSQL '-- Autogenerated file by dbo-generate-objects
';
    foreach my $object (@$objects) {
        my $name = $object->{name};
        my $tname = $name;
        $tname =~ s/_/ /go;

        print MYSQL '
DROP TABLE IF EXISTS ', camelize($name), ';
';
    }
    close(MYSQL);
}

#
# Generate MySQL schema code
#

if ((!$backend or $backend eq 'mysql') and $code) {

    open(MYSQL, '>:encoding(UTF-8)', 'libdbo_schema_mysql.h') or die;

    print MYSQL '/*
 * Autogenerated file by dbo-generate-objects
 */

#ifndef libdbo_schema_mysql_h
#define libdbo_schema_mysql_h

#ifdef __cplusplus
extern "C" {
#endif

extern const char* libdbo_schema_mysql_create[];
extern const char* libdbo_schema_mysql_drop[];

#ifdef __cplusplus
}
#endif

#endif
';
    close(MYSQL);
    
    open(MYSQL, '>:encoding(UTF-8)', 'libdbo_schema_mysql.c') or die;

    print MYSQL '/*
 * Autogenerated file by dbo-generate-objects
 */

const char* libdbo_schema_mysql_create[] = {
';
    foreach my $object (@$objects) {
        my $name = $object->{name};
        my $tname = $name;
        $tname =~ s/_/ /go;
    
        my $first = 1;
        my $str = 'CREATE TABLE '.camelize($name).' (';
        foreach my $field (@{$object->{fields}}) {
            if (!$first) {
                $str .= ', ';
            }
            $first = 0;
            if ($field->{type} eq 'DB_TYPE_PRIMARY_KEY') {
                $str .= ' '.camelize($field->{name}).' '.$DB_TYPE_TO_MYSQL{'DB_TYPE_PRIMARY_KEY'};
                next;
            }
            if ($field->{foreign}) {
                $str .= ' '.camelize($field->{name}).' BIGINT UNSIGNED NOT NULL';
                next;
            }
                $str .= ' '.camelize($field->{name}).' '.$DB_TYPE_TO_MYSQL{$field->{type}};
        }
        $str .= ')';
        my @parts = ( $str =~ m/.{1,500}/go );
        for my $part (@parts) {
            print MYSQL '    "', $part, '",
';
        }
        print MYSQL '    0,
';

        foreach my $field (@{$object->{fields}}) {
            my $str = '';
        
            if ($field->{foreign}) {
                $str = 'CREATE INDEX '.camelize($name.'_'.$field->{name}).' ON '.camelize($name).' ( '.camelize($field->{name}).($field->{type} eq 'DB_TYPE_TEXT' ? '(255)' : '').' )';
            }
            if ($field->{unique}) {
                $str = 'CREATE UNIQUE INDEX '.camelize($name.'_'.$field->{name}).' ON '.camelize($name).' ( '.camelize($field->{name}).($field->{type} eq 'DB_TYPE_TEXT' ? '(255)' : '').' )';
            }
            if (!$str) {
                next;
            }

            my @parts = ( $str =~ m/.{1,500}/go );
            for my $part (@parts) {
                print MYSQL '    "', $part, '",
';
            }
            print MYSQL '    0,
';
        }
    }
    print MYSQL '    0
};

const char* libdbo_schema_mysql_drop[] = {
';
    foreach my $object (@$objects) {
        my $name = $object->{name};

        print MYSQL '    "DROP TABLE IF EXISTS ', camelize($name), '",
    0,
';
    }
    print MYSQL '    0
};
';
    close(MYSQL);
}
